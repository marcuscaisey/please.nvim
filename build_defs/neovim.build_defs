# TODO: download neovim, lemmy-help by default if not configured in .plzconfig

subinclude("///shell//build_defs:shell")

def neovim_toolchain(name:str, version:str, hashes:list=[], visibility:list=["PUBLIC"]):
    """
    Downloads Neovim from GitHub and exposes the nvim binary as the entry point :<name>|nvim.

    To use this rule, add the following to your .plzconfig:

    [BuildConfig]
    nvim-tool = //...:<name>|nvim

    Args:
        name: Name of the target.
        version: The version of Neovim to download.
        hashes: A list of possible hashes for the downloaded archive. Optional.
        visibility: Visibility specification. Defaults to public.
    """
    urls_by_os = {
        "darwin": [
            f"https://github.com/neovim/neovim/releases/download/v{version}/nvim-macos.tar.gz",
            f"https://github.com/neovim/neovim/releases/download/v{version}/nvim-macos-{CONFIG.HOSTARCH}.tar.gz",
        ],
        "linux": f"https://github.com/neovim/neovim/releases/download/v{version}/nvim-linux64.tar.gz",
    }
    if CONFIG.HOSTOS not in urls_by_os:
        fail(f'neovim_toolchain rule is not supported on OS: "{CONFIG.HOSTOS}"')

    download = remote_file(
        name = tag(name, "download"),
        url = urls_by_os[CONFIG.HOSTOS],
        hashes = hashes,
        extract = True,
    )

    lua = genrule(
        name = tag(name, "lua"),
        srcs = [download],
        output_dirs = ["_out"],
        cmd = "mkdir _out && cp -r $SRCS/share/nvim/runtime/lua/* _out",
        labels = ["link:plz-out/nvim"],
    )

    return genrule(
        name = name,
        srcs = [download],
        cmd = "mv $SRCS $OUT",
        outs = [name],
        entry_points = {
            "nvim": f"{name}/bin/nvim",
        },
        deps = [lua],
        output_is_complete = True,
        visibility = visibility,
        building_description = "Installing...",
    )

def neovim_plugin(name:str, srcs:list=[], deps:list=[], help_srcs:list=[], help_opts:list=[], visibility:list=["PUBLIC"]):
    """
    Defines two Neovim plugin targets:
        1. <name> which collects the plugin's files for use by dependent neovim_lua_module and neovim_test targets.
        2. <name>_help_gen, a runnable target which generates a help file from Lua srcs using lemmy-help and copies it
        into the doc directory.
        2. <name>_help_gen_check, a runnable target which checks whether the help file needs to be regenerated. This is
        intended to be run in CI.

    Args:
        name: Name of the build target.
        srcs: Sources of the plugin. Optional.
        deps: Dependencies of the plugin. These should typically be neovim_lua_module targets. Optional.
        help_srcs: Lua sources to generate the help file from. Optional.
        help_opts: Options to pass to lemmy-help when generating the help file. Optional.
        visibility: Visibility specification. Defaults to public.
    """
    runtimepath = package_name() or "."
    runtimepath_rule = genrule(
        name = tag(name, "runtimepath"),
        out = f"{name}.runtimepath",
        cmd = f"echo {runtimepath} > $OUT",
    )

    if help_srcs:
        lemmy_help = check_config(
            key = "LEMMY_HELP_TOOL",
            section = "BuildConfig",
            rule = "neovim_plugin",
            example = "//third_party/neovim:toolchain|nvim",
        )

        joined_opts = " ".join(help_opts)
        help_file_rule = genrule(
            name = tag(name, "help"),
            srcs = help_srcs,
            outs = [f"{name}.txt"],
            tools = [lemmy_help],
            cmd = f"$TOOL {joined_opts} $SRCS > $OUT",
        )

        help_file_path = f"doc/{name}.txt"
        help_gen = sh_cmd(
            name = "help_gen",
            deps = [help_file_rule],
            cmd = f"mkdir -p doc && cp $(out_location {help_file_rule}) {help_file_path}",
        )

        sh_test(
            name = "help_gen_test",
            src = text_file(
                name = "test_script",
                content = "\n".join([
                    f"if ! diff --unified --color=always {help_file_path} $(location {help_file_rule}); then",
                    f'  echo {help_file_path} needs to be regenerated with "plz run //{help_gen}"',
                    "  exit 1",
                    "fi",
                ]),
                deps = [help_file_rule],
            ),
            data = [
                help_file_rule,
                help_file_path,
            ],
        )

    return filegroup(
        name = name,
        srcs = srcs + [runtimepath_rule],
        exported_deps = deps,
        visibility = visibility,
    )

def neovim_lua_module(name:str, srcs:list, deps:list=[], visibility:list=["PUBLIC"]):
    """
    Defines a Lua module target which collects Lua files for use by dependent neovim_lua_module, neovim_plugin, and
    neovim_test targets.

    Args:
        name: Name of the build target.
        srcs: Lua sources of the module.
        deps: Dependencies of the module. These should be neovim_lua_module, neovim_plugin, or neovim_github_plugin
              targets. Optional.
        visibility: Visibility specification. Defaults to public.
    """
    return filegroup(
        name = name,
        srcs = srcs,
        exported_deps = deps,
        visibility = visibility,
    )

def neovim_test(name:str, test_file:str, deps:list=[], labels:list=[], data:list=None, env:dict=None):
    """
    Defines a Neovim test target which runs a test file inside Neovim using busted
    (https://lunarmodules.github.io/busted).

    To use this rule you must have nvim-tool configured under the [BuildConfig] section in your .plzconfig. nvim-tool is
    the nvim binary used to run the test file. This can either be a path or the |nvim entry point which is generated by
    the neovim_toolchain build rule.

    For example:

    [BuildConfig]
    nvim-tool = //third_party/neovim:toolchain|nvim

    Args:
        name: Name of the build target.
        test_file: Test file to run.
        deps: Dependencies of the test. These should be neovim_lua_module, neovim_plugin, or neovim_github_plugin
              targets. Optional.
        labels: Labels to apply to this test. Optional.
        data: Runtime data files for the test. Optional.
        env: A dict of environment variables to be set inside the test env. Optional.
    """
    nvim = check_config(
        key = "NVIM_TOOL",
        section = "BuildConfig",
        rule = "neovim_test",
        example = "//third_party/neovim:toolchain|nvim",
    )

    return gentest(
        name = name,
        test_cmd = [
            "$TOOLS_ARCAT x $TEST",
            "$TOOLS_NVIM -u $DATA_INIT -l $DATA_RUNNER $DATA_FILE | sed '/./,$!d' | tee $RESULTS_FILE",
        ],
        labels = labels,
        cmd = "$TOOL z -d -n -i . -o $OUT",
        outs = ["deps.zip"],
        deps = deps + ["//third_party/lua:busted"],
        tools = [CONFIG.ARCAT_TOOL],
        test_tools = {
            "arcat": CONFIG.ARCAT_TOOL,
            "nvim": nvim,
        },
        data = {
            "file": test_file,
            "runner": "//build_defs:neovim_test_runner",
            "init": "//build_defs:neovim_test_init",
            "data": data,
        },
        env = env,
    )

def neovim_github_plugin(name:str, repo:str, revision:str, hashes:list=[], visibility:list=["PUBLIC"]):
    """
    Downloads a Neovim plugin from GitHub for use by dependent neovim_lua_module and neovim_test targets.

    Args:
        name: Name of the build target.
        repo: Repository to fetch from (e.g. "marcuscaisey/please.nvim").
        revision: Revision to download. This can be either a release version, commit or branch.
        hashes: List of hashes to verify the rule with.
        visibility: Visibility specification. Defaults to public.
    """
    org, _, repo = repo.partition("/")
    assert repo, "Must pass a valid GitHub repo argument, e.g. marcuscaisey/please.nvim"
    download = remote_file(
        name = tag(name, "download"),
        url = f"https://github.com/{org}/{repo}/archive/{revision}.zip",
        hashes = hashes,
        extract = True,
    )
    runtimepath = genrule(
        name = tag(name, "runtimepath"),
        srcs = [download],
        out = f"{name}.runtimepath",
        cmd = f"echo $SRC > $OUT",
    )
    lua = genrule(
        name = tag(name, "lua"),
        srcs = [download],
        output_dirs = ["_out"],
        cmd = "mkdir -p _out && cp -r $SRCS/lua/* _out",
        labels = ["link:plz-out/nvim"],
    )
    return filegroup(
        name = name,
        srcs = [
            download,
            runtimepath,
        ],
        output_is_complete = True,
        deps = [lua],
        visibility = visibility,
    )

def neovim_github_tree_sitter_parser(name:str, lang:str, repo:str, revision:str, hashes:list=[], visibility:list=["PUBLIC"]):
    """
    Downloads a tree sitter parser from GitHub and compiles it for use by dependent neovim_lua_module and neovim_test targets.

    Args:
        name: Name of the build target.
        lang: Language that this parser is for.
        repo: Repository to fetch from (e.g. "marcuscaisey/please.nvim").
        revision: Revision to download. This can be either a release version, commit or branch.
        hashes: List of hashes to verify the rule with.
        visibility: Visibility specification. Defaults to public.
    """
    subrepo_build_file = text_file(
        name = tag(name, "subrepo_build_file"),
        content = """
COMPILER_FLAGS = [
    "-Wno-deprecated",
    "-Wno-unused-but-set-variable",
]

c_library(
    name = "c",
    srcs = glob("src/*.c", allow_empty=True),
    hdrs = glob("src/tree_sitter/*.h"),
    compiler_flags = COMPILER_FLAGS,
    includes = ["src"],
    visibility = ["PUBLIC"],
)

cc_library(
    name = "cc",
    srcs = glob("src/*.cc", allow_empty=True),
    hdrs = glob("src/tree_sitter/*.h"),
    compiler_flags = COMPILER_FLAGS,
    includes = ["src"],
    visibility = ["PUBLIC"],
)

cc_shared_object(
    name = "parser",
    deps = [":c", ":cc"],
    visibility = ["PUBLIC"],
)
        """,
    )
    subrepo_name = tag(name, "subrepo")
    github_repo(
        name = subrepo_name,
        repo = repo,
        revision = revision,
        build_file = subrepo_build_file,
        hashes = hashes,
    )

    parser_target = "///" + join_path(package_name(), subrepo_name) + "//:parser"
    shared_object = genrule(
        name = tag(name, "shared_object"),
        srcs = [parser_target],
        outs = [name],
        cmd = f"mkdir -p {name}/parser && cp $SRC {name}/parser/{lang}.so",
    )

    runtimepath = genrule(
        name = tag(name, "runtimepath"),
        srcs = [shared_object],
        out = f"{name}.runtimepath",
        cmd = f"echo $SRC > $OUT",
    )

    return filegroup(
        name = name,
        srcs = [
            shared_object,
            runtimepath,
        ],
        visibility = visibility,
    )

def neovim_lemmy_help(name:str, version:str, hashes:list=[], visibility:list=["PUBLIC"]):
    """
    Downloads lemmy-help from GitHub.

    To use this rule, add the following to your .plzconfig:

    [BuildConfig]
    lemmy-help-tool = //...:<name>

    Args:
        name: Name of the target.
        version: The version of lemmy-help to download.
        hashes: A list of possible hashes for the downloaded archive. Optional.
        visibility: Visibility specification. Defaults to public.
    """
    urls_by_os = {
        "darwin": f"https://github.com/numToStr/lemmy-help/releases/download/v{version}/lemmy-help-x86_64-apple-darwin.tar.gz",
        "linux": f"https://github.com/numToStr/lemmy-help/releases/download/v{version}/lemmy-help-x86_64-unknown-linux-gnu.tar.gz",
    }
    if CONFIG.HOSTOS not in urls_by_os:
        fail(f'neovim_lemmy_help rule is not supported on OS: "{CONFIG.HOSTOS}"')

    return remote_file(
        name = name,
        url = urls_by_os[CONFIG.HOSTOS],
        extract = True,
        exported_files = ["lemmy-help"],
        binary = True,
        hashes = hashes,
        visibility = visibility,
    )
